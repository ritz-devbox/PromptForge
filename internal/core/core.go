package core

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/promptforge/promptforge/internal/compiler"
	"github.com/promptforge/promptforge/internal/ir"
)

// InitializeProject creates a new PromptForge project by creating a plan.md file.
// This is the core initialization logic, reusable by CLI and other consumers.
//
// Inputs:
//   - projectDir: Directory path where the promptforge/ directory will be created
//   - description: Optional rough idea/description that will populate the Goal section
//
// Outputs:
//   - Returns nil on success
//   - Returns error if:
//     - projectDir cannot be created
//     - plan.md already exists
//     - plan.md cannot be written
func InitializeProject(projectDir string, description string) error {
	// Validate project directory exists and is accessible
	if projectDir == "" {
		return fmt.Errorf("project directory cannot be empty")
	}
	
	// Check if project directory exists and is writable
	info, err := os.Stat(projectDir)
	if err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("project directory does not exist: %s", projectDir)
		}
		return fmt.Errorf("cannot access project directory %s: %w", projectDir, err)
	}
	if !info.IsDir() {
		return fmt.Errorf("project path is not a directory: %s", projectDir)
	}
	
	// Check write permissions
	testFile := filepath.Join(projectDir, ".promptforge_test")
	if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil {
		if os.IsPermission(err) {
			return fmt.Errorf("permission denied: cannot write to project directory %s", projectDir)
		}
		return fmt.Errorf("cannot write to project directory %s: %w", projectDir, err)
	}
	os.Remove(testFile) // Clean up test file
	
	// Create the promptforge directory if it doesn't exist
	promptforgeDir := filepath.Join(projectDir, "promptforge")
	if err := os.MkdirAll(promptforgeDir, 0755); err != nil {
		if os.IsPermission(err) {
			return fmt.Errorf("permission denied: cannot create promptforge directory in %s", projectDir)
		}
		return fmt.Errorf("failed to create promptforge directory: %w", err)
	}

	// Check if plan.md already exists
	planPath := filepath.Join(promptforgeDir, "plan.md")
	if _, err := os.Stat(planPath); err == nil {
		return fmt.Errorf("plan.md already exists at %s", planPath)
	}

	// Generate Goal section content
	goalSection := "<!-- Describe the intended purpose and outcome of this prompt -->"
	if description != "" {
		goalSection = description
	}

	// Create plan.md with guidance structure
	planContent := fmt.Sprintf(`# Prompt Plan

## Goal
%s

## Constraints
<!-- List the limitations, rules, and boundaries that must be respected -->

## Out of Scope
<!-- Explicitly state what this prompt should NOT handle or address -->

---

Note: This file is human-readable and editable. It is NOT authoritative.
The authoritative artifact is prompt.ir.json, generated by 'promptforge compile'.
`, goalSection)

	if err := os.WriteFile(planPath, []byte(planContent), 0644); err != nil {
		if os.IsPermission(err) {
			return fmt.Errorf("permission denied: cannot write plan.md to %s", planPath)
		}
		// Check for disk full error (ENOSPC on Unix, but Windows may return different errors)
		if err.Error() == "no space left on device" || err.Error() == "not enough space" {
			return fmt.Errorf("disk full: cannot write plan.md. Please free up disk space")
		}
		return fmt.Errorf("failed to create plan.md at %s: %w", planPath, err)
	}

	return nil
}

// CompileProject compiles a plan.md file into a PromptIR and writes it to disk.
// This is the core compilation logic, reusable by CLI and other consumers.
//
// Inputs:
//   - projectDir: Directory path containing the promptforge/ directory
//   - outputPath: Path where prompt.ir.json will be written
//
// Outputs:
//   - Returns the compiled PromptIR on success
//   - Returns error if:
//     - plan.md does not exist
//     - plan.md cannot be read
//     - plan.md is empty
//     - compilation fails
//     - IR validation fails
//     - output file cannot be written
func CompileProject(projectDir, outputPath string) (*ir.PromptIR, error) {
	// Validate project directory
	if projectDir == "" {
		return nil, fmt.Errorf("project directory cannot be empty")
	}
	
	// Check if project directory exists
	if _, err := os.Stat(projectDir); os.IsNotExist(err) {
		return nil, fmt.Errorf("project directory does not exist: %s", projectDir)
	}
	
	// Check if plan.md exists - fail loudly if it doesn't
	planPath := filepath.Join(projectDir, "promptforge", "plan.md")
	planInfo, err := os.Stat(planPath)
	if os.IsNotExist(err) {
		return nil, fmt.Errorf("plan.md not found at %s. Run 'promptforge init' first", planPath)
	}
	if err != nil {
		return nil, fmt.Errorf("cannot access plan.md at %s: %w", planPath, err)
	}
	
	// Check if plan.md is readable
	if planInfo.Size() == 0 {
		return nil, fmt.Errorf("plan.md is empty at %s", planPath)
	}

	// Read plan.md to verify it exists and is readable
	planContent, err := os.ReadFile(planPath)
	if err != nil {
		if os.IsPermission(err) {
			return nil, fmt.Errorf("permission denied: cannot read plan.md at %s", planPath)
		}
		return nil, fmt.Errorf("failed to read plan.md at %s: %w", planPath, err)
	}
	
	if len(planContent) == 0 {
		return nil, fmt.Errorf("plan.md is empty at %s", planPath)
	}

	// Compile to IR using hardcoded, conservative mapping
	// planContent is read but not interpreted - compiler generates deterministic IR
	ir, err := compiler.Compile(planContent)
	if err != nil {
		return nil, fmt.Errorf("compilation failed: %w", err)
	}

	// Validate output directory exists and is writable
	outputDir := filepath.Dir(outputPath)
	if outputDir != "." && outputDir != "" {
		if _, err := os.Stat(outputDir); os.IsNotExist(err) {
			return nil, fmt.Errorf("output directory does not exist: %s", outputDir)
		}
	}
	
	// Check write permissions for output directory
	testFile := filepath.Join(outputDir, ".promptforge_test")
	if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil {
		if os.IsPermission(err) {
			return nil, fmt.Errorf("permission denied: cannot write to output directory %s", outputDir)
		}
		return nil, fmt.Errorf("cannot write to output directory %s: %w", outputDir, err)
	}
	os.Remove(testFile) // Clean up test file
	
	// Write IR to JSON
	if err := compiler.WriteIR(ir, outputPath); err != nil {
		if os.IsPermission(err) {
			return nil, fmt.Errorf("permission denied: cannot write prompt.ir.json to %s", outputPath)
		}
		// Check for disk full error
		if err.Error() == "no space left on device" || err.Error() == "not enough space" {
			return nil, fmt.Errorf("disk full: cannot write prompt.ir.json. Please free up disk space")
		}
		return nil, fmt.Errorf("failed to write prompt.ir.json to %s: %w", outputPath, err)
	}

	return ir, nil
}


